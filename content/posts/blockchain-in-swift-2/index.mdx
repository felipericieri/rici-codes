---
title: "Building a Blockchain in Swift (Part. 2)"
date: 2021-10-27
slug: "/building-a-blockchain-in-swift-part2"
---

### How I've got here

This article is part of a serie of Building a Blockchain in Swift. You can find [here](/building-a-blockchain-in-swift-part1) the Part. 1.

### Getting started

I will keep this very simple and straight to the point. If you want to clone the sample project, you can find it [in my github](https://github.com/felipericieri/blockchain-in-swift). It uses Vapor 4 on top of Swift NIO 2.33.0, Xcode 13 and Swift 5.2.

#### Blockchain & the Blocks

Zooming out: a Blockchain is a kind of database. You can use to whatever you want, it is just a wait to persist data. In our experiment, it will have a collection of transactions. 

This data is stored in the shape of "blocks" and chained together by a cryptographic hash. So information is added to this database gradually and chronologically. Every block needs to refer the previous block hash (that's how the chaining mechanism works). As a block will be added after another, each one will have a "position" in the chain (or _height_). The first block in the chain is considered the _genesis_ block. Is the only one that doesn't have a link to a previous block (holds an invalid address instead).

![Simple blockchain illustrated](/posts-images/blockchain-in-swift_img1.png "Simple blockchain illustrated")

#### First steps: Transactions

In our experiment, the transaction is fairly simple. Let's assume it's structured as follows:

```swift
struct Transaction {
  /// Sender
  let from: String
  /// Receiver
  let to: String
  /// Amount of value
  let amount: Double
}
```

It takes the sender and the recipient of an transaction, which in our case can be any valid `String`, and the amount of value that is being transfered. Again, in the market this object has many others features. But that's what we'll need for now.

#### Destructuring the Block

How does a block looks like from within, you may ask? Blockchains have a tons of features that we'll not quite need in our own, so to keep it simple bear the declaration below:

```swift
final class Block {
  // The height the block is in the chain
  private(set) var height: UInt 
  // Reference to the hash of the previous block
  private(set) var previousHash: String 
  // The block hash. It is `nil` until the block is minted
  var hash: String!
  // Random value that
  private(set) var nonce: UInt = 0
  // Transactions added to the block
  private(set) var transactions: [Transaction]

  // MARK: - Initialiser

  init(height: UInt, previousHash: String) {
    self.height = height
    self.previousHash = previousHash
    transactions = []
  }

  // MARK: - Block features
  
  /// Adds a transaction to this block
  func add(transaction: [String: AnyHashable]) {
    transactions.append(transaction)
  }

  /// Increments nonce
  func incrementsNonce() {
    nonce += 1
  }
}
```

A block will always have no hash until it is minted. It can only be minted if it complies with the blockchain current difficulty (which is the mathematical problem it needs to solve). In our case, we want to find a hash prefixed with a certain repetition of zeroes.

The block also has the ability to add transactions to itself. These transactions will be flatten in a JSON object that will be used in the hash computation.

If you are wondering what the `nonce` property is about, don't worry for now. This is just a numerical value that we'll help us in the mining process. We'll cover it later.

The hash should be computed consuming all block information. For this example, we'll go with a custom hash for our block that uses the [SHA-1](https://en.wikipedia.org/wiki/SHA-1) hashing function (also to be covered later on!). So we'll need to convey in some kind of key that wraps all our block data so we can hash it.

```swift
func generateKey() -> String {
  let transactionsData = try! JSONEncoder().encode(transactions)
  let transactionJsonString = String(data: transactionsData, encoding: .utf8)!
  return String(height) + previousHash + String(nonce) + transactionJsonString
}
```

> ⚠️ SHA-1 is a unsecure cryptographic hash function. Bitcoin uses a double-hashed SHA-256 hash, and you should also consider more robust hashing algorithms, but for the sake of the experiment we'll go with SHA-1.

Great! Now we have a single argument to feed our SHA-1 function and get our block a hash.

> ⚠️ Transaction will need to conform to `Encodable` so it can be encoded to JSON.

Next, let's design how the Blockchain will look like:

```swift
final class Blockchain {

  enum Error: Swift.Error {
    case invalidBlockHash
  }

  /// Collection of blocks in this chain
  private(set) var blocks: [Block] = []
  
  // MARK: - Initialiser
  
  init(genesisBlock: Block) throws {
    guard genesisBlock.hash != nil else {
      throw Error.invalidBlockHash
    }

    blocks.append(genesisBlock)
  }

  // MARK: - Blockchain features

  /// Adds a block to the chain
  func add(block: Block) throws {
    guard block.hash != nil else {
      throw Error.invalidBlockHash
    }

    blocks.append(block)
  }
}
```

The blockchain holds the reference for the blocks and takes a block upon initialisation (the genesis block). The blockchain also has the capability to add more blocks to the chain.

Every block need to be minted (i.e. has a valid hash) before being added to the blockchain. We throw an error if the block was tried to be added to the chain without a hash.

#### Side note

If you take a closer look, you'll also notice that there's no reference whatsoever to the kind of value we are transactioning here (aka the currency). This is true in blockchains in the market as well. Bitcoin, Ether, Ripple, etc are just names given to the value that is being transfered from a wallet to another, but there's no _real_ (virtual or material) image of it. It is just a value in the records, which by the convention is known as the cryptocurrency itself.

### Next steps

Next we'll explore the mining feature. Follow up for [Part. 3](/building-a-blockchain-in-swift-part3).

